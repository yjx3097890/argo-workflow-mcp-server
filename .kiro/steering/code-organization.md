---
inclusion: always
---

# 代码组织规范

## 模块化原则

在编写代码时，必须遵循以下模块化原则：

### 1. 文件大小限制

- **单个文件不应超过 300 行代码**
- 如果文件超过 300 行，必须按功能拆分为多个模块
- 注释和空行也计入行数

### 2. 功能拆分策略

当文件接近或超过 300 行时，应按以下方式拆分：

#### 按职责拆分
- 将不同职责的代码分离到不同的模块
- 例如：数据模型、业务逻辑、错误处理、工具函数等

#### 按功能域拆分
- 将相关功能组织到子模块中
- 例如：`user/mod.rs`, `user/auth.rs`, `user/profile.rs`

#### 按抽象层次拆分
- 高层抽象和底层实现分离
- 例如：接口定义、具体实现、辅助工具

### 3. 模块组织示例

```
src/
├── lib.rs              # 模块导出和公共接口（< 100 行）
├── models/             # 数据模型
│   ├── mod.rs         # 模型模块入口
│   ├── request.rs     # 请求模型
│   ├── response.rs    # 响应模型
│   └── task.rs        # 任务模型
├── services/          # 业务逻辑
│   ├── mod.rs
│   ├── converter.rs   # 转换服务
│   └── storage.rs     # 存储服务
├── handlers/          # 请求处理器
│   ├── mod.rs
│   ├── sync.rs        # 同步转换处理
│   └── async.rs       # 异步转换处理
└── utils/             # 工具函数
    ├── mod.rs
    └── validation.rs  # 验证工具
```

### 4. 拆分时机

当遇到以下情况时，应立即考虑拆分：

- 文件超过 250 行（预留缓冲空间）
- 一个文件包含多个不相关的功能
- 代码难以导航和理解
- 测试文件过于庞大

### 5. 拆分步骤

1. **识别功能边界**：找出可以独立的功能模块
2. **创建新模块**：为每个功能创建独立的文件
3. **移动代码**：将相关代码移动到新模块
4. **更新导入**：在 `mod.rs` 中声明和导出新模块
5. **验证编译**：确保代码仍然可以正常编译

### 6. 模块命名规范

- 使用小写字母和下划线：`user_service.rs`
- 模块名应清晰表达其功能
- 避免使用缩写，除非是广泛认可的术语

### 7. 公共接口设计

- 在 `mod.rs` 或 `lib.rs` 中明确导出公共 API
- 使用 `pub use` 重新导出常用类型
- 隐藏内部实现细节

```rust
// lib.rs 示例
pub mod models;
pub mod services;
mod internal;  // 私有模块

// 重新导出常用类型
pub use models::{Request, Response};
pub use services::ConverterService;
```

### 8. 特殊情况

以下情况可以适当放宽 300 行限制：

- 大型枚举定义（如错误类型）
- 自动生成的代码
- 测试文件（但仍建议拆分）

但即使在这些情况下，也应尽量保持在 400 行以内。

## 执行要求

- 在编写新代码时，从一开始就按模块化方式组织
- 在修改现有代码时，如果文件超过 300 行，必须先进行拆分
- 代码审查时，检查文件大小是否符合规范
- 使用 `wc -l` 命令检查文件行数：`wc -l src/**/*.rs`

## 好处

遵循这些规范可以带来：

- **更好的可维护性**：小文件更容易理解和修改
- **更清晰的职责划分**：每个模块有明确的功能
- **更容易的测试**：小模块更容易编写单元测试
- **更好的协作**：减少合并冲突的可能性
- **更快的编译**：Rust 可以并行编译独立模块
